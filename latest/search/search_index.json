{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"About","text":"In\u00a0[1]: Copied! <pre>from mxlbricks import names as n\n\n# Default case\nprint(n.atp_synthase())\n\n# Localised to cytosol\nprint(n.atp_synthase(\"_cyt\"))\n</pre> from mxlbricks import names as n  # Default case print(n.atp_synthase())  # Localised to cytosol print(n.atp_synthase(\"_cyt\")) <pre>atp_synthase\natp_synthase_cyt\n</pre> In\u00a0[2]: Copied! <pre>from mxlpy import Model, fns\n\nfrom mxlbricks.utils import static\n\n\ndef add_dummy_reaction(\n    model: Model,\n    compartment: str,\n    e0: str | None = None,\n    kcat: str | None = None,\n    km: str | None = None,\n) -&gt; Model:\n    \"\"\"Dummy enzyme-catalysed, irreversible reaction.\n\n    1 substrate =&gt; 1 product\n    \"\"\"\n    rxn_name = n.dummy(compartment)\n\n    # Default parameter description if none is given\n    e0 = static(model, n.e0(rxn_name), value=1.0) if e0 is None else e0\n    kcat = static(model, n.kcat(rxn_name), value=1.0) if kcat is None else kcat\n    km = static(model, n.km(rxn_name), value=0.1) if km is None else km\n\n    # Derive vmax from e0 and kcat\n    model.add_derived(vmax := n.vmax(rxn_name), fn=fns.proportional, args=[kcat, e0])\n\n    # Add the reaction\n    model.add_reaction(\n        name=rxn_name,\n        fn=fns.michaelis_menten_1s,\n        args=[\n            n.a0(compartment),\n            vmax,\n            km,\n        ],\n        stoichiometry={\n            n.a0(compartment): -1,\n            n.a1(compartment): 1,\n        },\n    )\n    return model\n</pre> from mxlpy import Model, fns  from mxlbricks.utils import static   def add_dummy_reaction(     model: Model,     compartment: str,     e0: str | None = None,     kcat: str | None = None,     km: str | None = None, ) -&gt; Model:     \"\"\"Dummy enzyme-catalysed, irreversible reaction.      1 substrate =&gt; 1 product     \"\"\"     rxn_name = n.dummy(compartment)      # Default parameter description if none is given     e0 = static(model, n.e0(rxn_name), value=1.0) if e0 is None else e0     kcat = static(model, n.kcat(rxn_name), value=1.0) if kcat is None else kcat     km = static(model, n.km(rxn_name), value=0.1) if km is None else km      # Derive vmax from e0 and kcat     model.add_derived(vmax := n.vmax(rxn_name), fn=fns.proportional, args=[kcat, e0])      # Add the reaction     model.add_reaction(         name=rxn_name,         fn=fns.michaelis_menten_1s,         args=[             n.a0(compartment),             vmax,             km,         ],         stoichiometry={             n.a0(compartment): -1,             n.a1(compartment): 1,         },     )     return model <p>The reaction takes a <code>Model</code> object, any localisation information (e.g. <code>compartment</code>) and optionally parameters as names.</p> <pre>def add_dummy_reaction(\n    model: Model,\n    compartment: str,\n    e0: str | None = None,\n    kcat: str | None = None,\n    km: str | None = None,\n)\n</pre> In\u00a0[3]: Copied! <pre>def constant(model: Model, name: str, value: float) -&gt; str:\n    model.add_parameter(name, value)\n    return name\n</pre> def constant(model: Model, name: str, value: float) -&gt; str:     model.add_parameter(name, value)     return name <p>However, the reaction might also be regulated by a thioredoxin system.</p> <p>In that case we would not be interested in the total amount of the enzyme, but rather it's active fraction.</p> In\u00a0[4]: Copied! <pre>def thioredixon_regulated(model: Model, name: str, value: float) -&gt; str:\n    model.add_parameter(name, value)\n\n    derived_name = f\"{name}_active\"\n    model.add_derived(derived_name, fns.proportional, args=[name, n.e_active()])\n    return derived_name\n</pre> def thioredixon_regulated(model: Model, name: str, value: float) -&gt; str:     model.add_parameter(name, value)      derived_name = f\"{name}_active\"     model.add_derived(derived_name, fns.proportional, args=[name, n.e_active()])     return derived_name <p>Using this approach, we can easily switch between the two descriptions by simply injecting the appropriate function.</p> <pre># here the function depends on `E0_dummy`\nadd_dummy_reaction(..., e0=static(model, n.e0(n.dummy()), value=1.0))\n\n# here the function depends on `E0_dummy_active`\nadd_dummy_reaction(..., e0=thioredixon_regulated(model, n.e0(n.dummy()), value=1.0))\n</pre>"},{"location":"index.html#mxlbricks","title":"MxlBricks\u00b6","text":"<p><code>mxlbricks</code> is a library built on top of MxlPy to enable quick building of mechanistic learning models.</p>"},{"location":"index.html#motivation","title":"Motivation\u00b6","text":"<p>It is desirable to be able to build larger-scale metabolic models from smaller components, which can be tested and analysed in detail.</p> <p>However, in the last decades we have not seen widespread use of such successful model composition.</p> <p>We want to argue that this is due to the fact that most attempts to compose larger models use either entire existing models or metabolic pathways as the unit of composition.</p> <p>However, the idealisation of a metabolic pathway as an isolated entity is not a realistic assumption, as it ignores the fact that the pathway is embedded in a larger network of reactions.</p> <p>This is especially problematic regarding choices of energy and redox equivalents.</p> <p>These are frequently described as either parameters, conserved quantities or free variables in different models, depending on the context.</p> <p>This leads to incompatibilities between the models.</p> <p>We thus believe that the unit of composition should be the individual reactions and those reactions need to be described in a way that allows for the description of other model components to vary depending on the use case.</p>"},{"location":"index.html#practical-problems","title":"Practical problems\u00b6","text":"<p>Other problems are of a more practical nature, such as differences in naming conventions.</p> <p>For this we propose a shared set of names which we store in the <code>names</code> module.</p> <p>To enable localisation of the reactions, we also provide the option to inject compartment information.</p> <pre>def atp_synthase(compartment: str = \"\") -&gt; str: ...\n</pre>"},{"location":"index.html#reaction-definition","title":"Reaction definition\u00b6","text":"<p>All reactions in <code>mxl-bricks</code> are defined in a similar way.</p> <p>We will first show an entire example and then step through it, explaining the rationale behind the choices made.</p>"},{"location":"index.html#injecting-parameters","title":"Injecting parameters\u00b6","text":"<p>The names are given as strings, so that they can be easily replaced by the user.</p> <p>In this way the reaction does neither impose a name nor other features.</p> <p>Note: this technique is called dependency injection.</p> <p>This is especially useful for different descriptions of the same reaction.</p> <p>For example, the concentration of the enzyme could be assumed to be constant, in which case a normal parameter would be appropriate.</p>"},{"location":"index.html#default-parameters","title":"Default parameters\u00b6","text":"<p>Inside the function, the parameters are then initialised to default values if they are not given</p> <pre>e0 = static(model, n.e0(rxn_name), value=1.0) if e0 is None else e0\n</pre> <p>This is done to avoid overly redundant code in case the parameter description is always the same.</p> <p>For example, it is a lot easier to see the difference between these two descriptions</p> <pre>add_dummy_reaction(\n    model,\n    compartment=\"_chl\",\n)\n\nadd_dummy_reaction(\n    model,\n    compartment=\"_chl\",\n    e0=thioredixon_regulated(model, name=n.e0(rxn_name), value=1.0),\n)\n</pre> <p>rather than these two</p> <pre>add_dummy_reaction(\n    model,\n    compartment=\"_chl\",\n    e0=static(model, name=n.e0(rxn_name), value=1.0),\n    kcat=static(model, name=n.kcat(rxn_name), value=1.0),\n    km=static(model, name=n.km(rxn_name), value=0.1),\n)\n\nadd_dummy_reaction(\n    model,\n    compartment=\"_chl\",\n    e0=thioredixon_regulated(model, name=n.e0(rxn_name), value=1.0),\n    kcat=static(model, name=n.kcat(rxn_name), value=1.0),\n    km=static(model, name=n.km(rxn_name), value=0.1),\n)\n</pre>"},{"location":"index.html#derived-vmax-values","title":"Derived vmax values\u00b6","text":"<p><code>mxl-bricks</code> does not make any assumption about the rate laws used in the model. However, in the case of any Michaelis-Menten-type rate law, it is recommended to derive the <code>vmax</code> from the <code>kcat</code> and the concentration of the enzyme.</p> <p>This makes it a lot easier to compare the actual <code>kcat</code> values chosen against databases like BRENDA.</p> <pre># Derive vmax from e0 and kcat\nmodel.add_derived(vmax := n.vmax(rxn_name), fn=fns.proportional, args=[kcat, e0])\n</pre> <p>As MxlPy supports derived values from both parameters and variables, this code does not need to be changed between the two descriptions.</p>"},{"location":"index.html#filtered-stoichiometries","title":"Filtered stoichiometries\u00b6","text":"<p>By default, we will define the stoichiometries of a reaction like the following:</p> <pre>stoichiometry={\n    n.a0(compartment): -1,\n    n.a1(compartment): 1,\n}\n</pre> <p>However, especially with different descriptions of energy and redox equivalents, not all of the stoichiometries might actually be variables. In that case, we can use the <code>filter_stoichiometry</code> function to filter out the stoichiometries that are not actually variables.</p> <pre>from mxlbricks.utils import filter_stoichiometry\n\nmodel.add_reaction(\n        ...\n        stoichiometry=filter_stoichiometry(\n            model,\n            stoichiometry={\n                n.a0(compartment): -1,\n                n.a1(compartment): 1,\n            },\n        ),\n    )\n</pre>"},{"location":"index.html#model-building","title":"Model building\u00b6","text":"<p>With this, models can be composed from</p> <ul> <li>a set of variables</li> <li>a set of parameters</li> <li>(potentially) a set of derived quantities</li> <li>a set of reactions</li> </ul> <pre>def get_model() -&gt; Model:\n    model = Model()\n    model.add_variables({n.atp(): 1.0, ...})\n    model.add_parameters({n.ph(): 7.0, ...})\n\n    # Add reactions to the model\n    add_reaction1(model)\n    add_reaction2(model)\n    add_reaction3(model)\n    ...\n    return model\n</pre>"},{"location":"index.html#design-recommendations","title":"Design recommendations\u00b6","text":"<p>We recommend to include all parameters of a reaction in the description of the reaction, such that it is a self-contained unit.</p> <p>However, sometimes parameters might be shared between reactions.</p> <p>In that case, we recommend to still define the parameter in each reaction, but then pass the default value to each of the reactions.</p> <pre>def get_model() -&gt; Model:\n    model = Model()\n    model.add_parameters({n.ph(): 7.0, ...})\n\n    # Inject the parameters into the reactions\n    add_reaction1(model, ph=n.ph())\n    add_reaction2(model, ph=n.ph())\n    ...\n    return model\n</pre>"},{"location":"index.html#discarded-design-decisions","title":"Discarded design decisions\u00b6","text":""},{"location":"index.html#model-inheritance","title":"Model inheritance\u00b6","text":"<p>We initially considered using inheritance to build models from smaller components. In the context of models, this could look something like this:</p> <pre>def build_model_v1() -&gt; Model: ...\ndef build_model_v2(model_v1: Model) -&gt; Model: ...\n</pre> <p>However, this makes changes to models difficult, as other models may depend on the model you are trying to change. Thus, the entire chain of models becomes rigid and difficult to change. So while a composition approach requires more boilerplate code and repetition, it is much more flexible.</p>"},{"location":"__init__.html","title":"init","text":""},{"location":"models.html","title":"Overview","text":"In\u00a0[1]: Copied! <pre>import plot_\nfrom mxlpy import Assimulo, Simulator, plot, unwrap\n\nfrom mxlbricks import (\n    get_matuszynska2016npq,\n    get_matuszynska2019,\n    get_poolman2000,\n    get_saadat2021,\n    get_yokota1985,\n)\n</pre> import plot_ from mxlpy import Assimulo, Simulator, plot, unwrap  from mxlbricks import (     get_matuszynska2016npq,     get_matuszynska2019,     get_poolman2000,     get_saadat2021,     get_yokota1985, ) In\u00a0[2]: Copied! <pre>model = get_yokota1985()\nres = unwrap(Simulator(model).simulate(100).get_result())\n\nfig, ax = plot.lines(res.get_variables(), xlabel=\"Time / h\", ylabel=\"Conc / (mmol / L)\")\nax.legend(loc=\"upper left\", bbox_to_anchor=(1, 1), ncols=1)\nplot.show()\n</pre> model = get_yokota1985() res = unwrap(Simulator(model).simulate(100).get_result())  fig, ax = plot.lines(res.get_variables(), xlabel=\"Time / h\", ylabel=\"Conc / (mmol / L)\") ax.legend(loc=\"upper left\", bbox_to_anchor=(1, 1), ncols=1) plot.show() In\u00a0[3]: Copied! <pre>model = get_poolman2000()\nres = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())\n\nfig, ax = plot.lines(\n    res.get_variables(),\n    xlabel=\"Time / s\",\n    ylabel=\"Conc / (mmol / L)\",\n)\nax.legend(loc=\"upper left\", bbox_to_anchor=(1, 1), ncols=1)\nplot.show()\n</pre> model = get_poolman2000() res = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())  fig, ax = plot.lines(     res.get_variables(),     xlabel=\"Time / s\",     ylabel=\"Conc / (mmol / L)\", ) ax.legend(loc=\"upper left\", bbox_to_anchor=(1, 1), ncols=1) plot.show() In\u00a0[4]: Copied! <pre>model = get_matuszynska2016npq()\nres = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())\n\nfig, ax = plot.line_autogrouped(\n    res.get_variables(include_derived_variables=False),\n    xlabel=\"Time / s\",\n    ylabel=\"Conc / (mmol / L)\",\n    n_cols=3,\n)\nplot.show()\n</pre> model = get_matuszynska2016npq() res = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())  fig, ax = plot.line_autogrouped(     res.get_variables(include_derived_variables=False),     xlabel=\"Time / s\",     ylabel=\"Conc / (mmol / L)\",     n_cols=3, ) plot.show() In\u00a0[5]: Copied! <pre>model = get_matuszynska2019()\nres = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())\n\nfig, ax = plot_.line_autogrouped(\n    res.get_variables(include_derived_variables=False),\n    xlabel=\"Time / s\",\n    ylabel=\"Conc / (mmol / L)\",\n    n_cols=3,\n    min_group_size=2,\n)\nplot.show()\n</pre> model = get_matuszynska2019() res = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())  fig, ax = plot_.line_autogrouped(     res.get_variables(include_derived_variables=False),     xlabel=\"Time / s\",     ylabel=\"Conc / (mmol / L)\",     n_cols=3,     min_group_size=2, ) plot.show() In\u00a0[6]: Copied! <pre>model = get_saadat2021()\nres = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())\n\nfig, ax = plot_.line_autogrouped(\n    res.get_variables(include_derived_variables=False),\n    xlabel=\"Time / s\",\n    ylabel=\"Conc / (mmol / L)\",\n    n_cols=3,\n    min_group_size=4,\n    max_group_size=9,\n)\nplot.show()\n</pre> model = get_saadat2021() res = unwrap(Simulator(model, integrator=Assimulo).simulate(100).get_result())  fig, ax = plot_.line_autogrouped(     res.get_variables(include_derived_variables=False),     xlabel=\"Time / s\",     ylabel=\"Conc / (mmol / L)\",     n_cols=3,     min_group_size=4,     max_group_size=9, ) plot.show()"},{"location":"models.html#models","title":"Models\u00b6","text":""},{"location":"models.html#yokota-1985","title":"Yokota 1985\u00b6","text":"<p>Original article: Refixation of Photorespired CO2 during Photosynthesis in Euglena gracilis z</p> <p>by Akiho Yokota , Hiroshi Komura , Shozaburo Kitaoka</p>"},{"location":"models.html#poolman-2000","title":"Poolman 2000\u00b6","text":"<p>Original article: Modelling photosynthesis and its control</p> <p>by Mark G. Poolman , David A. Fell , Simon Thomas</p>"},{"location":"models.html#matuszynska-2016-npq","title":"Matuszy\u0144ska 2016 (NPQ)\u00b6","text":"<p>The Matuszynska2016 model, a small kinetic model, was developed to delve deeper into the effect of light memory caused by non-photochemical quenching. The systematic investigation of the Xanthophyll cycle, a combination of the pigments of violaxanthin, antheraxanthin, and zeaxanthin, sparked a series of experiments to determine whether plant light memory can be detected in a time-scale of minutes to hours through pulse amplitude modulated chlorophyll fluorescence. The model was then created based on these experimental results, providing a comprehensive description of NPQ dynamics and the short-term memory of the Arabidopsis thaliana plant.</p> <p>To keep the model as simple as possible, several processes not directly linked to NPQ have been simplified to create a dynamic ODE system consisting only of 6 different compounds. With these simplifications, the authors could fulfil an additional goal: to make a general framework that is not specific to one model organism.</p> <p>To demonstrate the adaptability of their model, the authors took their calibrated Arabidopsis thaliana model and successfully applied it to the non-model organism Epipremnum aureum. This adaptation allowed them to simulate realistic fluorescence measurements and replicate all the key features of chlorophyll induction, showcasing the model's versatility and potential for use in a variety of organisms.</p>"},{"location":"models.html#matuszynska-2019","title":"Matuszy\u0144ska 2019\u00b6","text":"<p>Original article: Balancing energy supply during photosynthesis \u2013 a theoretical perspective</p> <p>by Anna Matuszy\u0144ska, Nima P. Saadat, Oliver Ebenh\u00f6h</p> <p>The photosynthetic electron transport chain (PETC) provides energy and redox equivalents for carbon fixation by the Calvin-Benson-Bassham (CBB) cycle. Both of these processes have been thoroughly investigated and the underlying molecular mechanisms are well known. However, it is far from understood by which mechanisms it is ensured that energy and redox supply by photosynthesis matches the demand of the downstream processes. Here, we deliver a theoretical analysis to quantitatively study the supply\u2013demand regulation in photosynthesis. For this, we connect two previously developed models, one describing the PETC, originally developed to study non-photochemical quenching, and one providing a dynamic description of the photosynthetic carbon fixation in C3 plants, the CBB Cycle. The merged model explains how a tight regulation of supply and demand reactions leads to efficient carbon fixation. The model further illustrates that a stand-by mode is necessary in the dark to ensure that the carbon fixation cycle can be restarted after dark\u2013light transitions, and it supports hypotheses, which reactions are responsible to generate such mode in vivo.</p>"},{"location":"models.html#saadat-2021","title":"Saadat 2021\u00b6","text":"<p>Original article: Computational Analysis of Alternative Photosynthetic Electron Flows Linked With Oxidative Stress</p> <p>by Nima P. Saadat, Tim Nies, Marvin van Aalst, Brandon Hank, B\u00fcsra Demirtas, Oliver Ebenh\u00f6h, Anna Matuszy\u0144ska</p> <p>During photosynthesis, organisms respond to their energy demand and ensure the supply of energy and redox equivalents that sustain metabolism. Hence, the photosynthetic apparatus can, and in fact should, be treated as an integrated supply-demand system. Any imbalance in the energy produced and consumed can lead to adverse reactions, such as the production of reactive oxygen species (ROS). Reaction centres of both photosystems are known sites of ROS production. Here, we investigate in particular the central role of Photosystem I (PSI) in this tightly regulated system. Using a computational approach we have expanded a previously published mechanistic model of C3 photosynthesis by including ROS producing and scavenging reactions around PSI. These include two water to water reactions mediated by Plastid terminal oxidase (PTOX) and Mehler and the ascorbate-glutathione (ASC-GSH) cycle, as a main non-enzymatic antioxidant. We have used this model to predict flux distributions through alternative electron pathways under various environmental stress conditions by systematically varying light intensity and enzymatic activity of key reactions. In particular, we studied the link between ROS formation and activation of pathways around PSI as potential scavenging mechanisms. This work shines light on the role of alternative electron pathways in photosynthetic acclimation and investigates the effect of environmental perturbations on PSI activity in the context of metabolic productivity.</p>"},{"location":"plot_.html","title":"Plot","text":"In\u00a0[1]: Copied! <pre>from __future__ import annotations\n</pre> from __future__ import annotations In\u00a0[2]: Copied! <pre>import pandas as pd\nfrom mxlpy import plot\nfrom mxlpy.plot import (\n    Color,\n    FigAxs,\n    Linestyle,\n    _partition_by_order_of_magnitude,\n    _split_large_groups,\n)\n</pre> import pandas as pd from mxlpy import plot from mxlpy.plot import (     Color,     FigAxs,     Linestyle,     _partition_by_order_of_magnitude,     _split_large_groups, ) In\u00a0[3]: Copied! <pre>def _combine_small_groups(\n    groups: list[list[str]], min_group_size: int\n) -&gt; list[list[str]]:\n    \"\"\"\n    Combine adjacent groups if their size is smaller than min_group_size.\n\n    Args:\n        groups: List of lists of strings\n        min_group_size: Minimum size for a group to remain separate\n\n    Returns:\n        List of lists with small adjacent groups combined\n    \"\"\"\n    result = []\n    current_group = groups[0]\n\n    for next_group in groups[1:]:\n        if len(current_group) &lt; min_group_size:\n            current_group.extend(next_group)\n        else:\n            result.append(current_group)\n            current_group = next_group\n\n    # Last group\n    if len(current_group) &lt; min_group_size:\n        result[-1].extend(current_group)\n    else:\n        result.append(current_group)\n    return result\n</pre> def _combine_small_groups(     groups: list[list[str]], min_group_size: int ) -&gt; list[list[str]]:     \"\"\"     Combine adjacent groups if their size is smaller than min_group_size.      Args:         groups: List of lists of strings         min_group_size: Minimum size for a group to remain separate      Returns:         List of lists with small adjacent groups combined     \"\"\"     result = []     current_group = groups[0]      for next_group in groups[1:]:         if len(current_group) &lt; min_group_size:             current_group.extend(next_group)         else:             result.append(current_group)             current_group = next_group      # Last group     if len(current_group) &lt; min_group_size:         result[-1].extend(current_group)     else:         result.append(current_group)     return result In\u00a0[4]: Copied! <pre>def line_autogrouped(\n    s: pd.Series | pd.DataFrame,\n    *,\n    n_cols: int = 2,\n    col_width: float = 4,\n    row_height: float = 3,\n    min_group_size: int = 1,\n    max_group_size: int = 6,\n    grid: bool = True,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    color: Color | list[list[Color]] | None = None,\n    linewidth: float | None = None,\n    linestyle: Linestyle | None = None,\n) -&gt; FigAxs:\n    group_names = (\n        _partition_by_order_of_magnitude(s)\n        if isinstance(s, pd.Series)\n        else _partition_by_order_of_magnitude(s.max())\n    )\n    group_names = _combine_small_groups(group_names, min_group_size=min_group_size)\n    group_names = _split_large_groups(group_names, max_size=max_group_size)\n\n    groups: list[pd.Series] | list[pd.DataFrame] = (\n        [s.loc[group] for group in group_names]\n        if isinstance(s, pd.Series)\n        else [s.loc[:, group] for group in group_names]\n    )\n\n    return plot.lines_grouped(\n        groups,\n        n_cols=n_cols,\n        col_width=col_width,\n        row_height=row_height,\n        grid=grid,\n        color=color,\n        linestyle=linestyle,\n        linewidth=linewidth,\n        xlabel=xlabel,\n        ylabel=ylabel,\n    )\n</pre> def line_autogrouped(     s: pd.Series | pd.DataFrame,     *,     n_cols: int = 2,     col_width: float = 4,     row_height: float = 3,     min_group_size: int = 1,     max_group_size: int = 6,     grid: bool = True,     xlabel: str | None = None,     ylabel: str | None = None,     color: Color | list[list[Color]] | None = None,     linewidth: float | None = None,     linestyle: Linestyle | None = None, ) -&gt; FigAxs:     group_names = (         _partition_by_order_of_magnitude(s)         if isinstance(s, pd.Series)         else _partition_by_order_of_magnitude(s.max())     )     group_names = _combine_small_groups(group_names, min_group_size=min_group_size)     group_names = _split_large_groups(group_names, max_size=max_group_size)      groups: list[pd.Series] | list[pd.DataFrame] = (         [s.loc[group] for group in group_names]         if isinstance(s, pd.Series)         else [s.loc[:, group] for group in group_names]     )      return plot.lines_grouped(         groups,         n_cols=n_cols,         col_width=col_width,         row_height=row_height,         grid=grid,         color=color,         linestyle=linestyle,         linewidth=linewidth,         xlabel=xlabel,         ylabel=ylabel,     )"},{"location":"saadat2021.html","title":"Saadat 2021","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom mxlpy import Assimulo, Simulator, make_protocol, unwrap\n\nfrom mxlbricks import names as n\nfrom mxlbricks.models import get_saadat2021\n\n\ndef get_npq(ppfd: pd.Series, fluorescence: pd.Series) -&gt; pd.Series:\n    \"\"\"Calculates the non-photochemical quenching from the extracted\n    important points of the PAM simulations\n\n    Returns\n    -------\n    Fm: Fm (first element of list) and Fm' values\n    NPQ: Calculated NPQ values\n    tm: Exact time points of peaks in PAM trace\n    Fo: Fo (first element of list) and Ft' values\n    to: Exact time points of Fo and Ft' values\n    \"\"\"\n    # container for lists. Each list contains the positions of fluorescence values for one peak\n    # container for position of Fo'\n    z = []\n    o = []\n    light = ppfd.to_numpy()\n    t = ppfd.index.to_numpy()\n    fluorescence = fluorescence.to_numpy()\n    max_light = max(light)\n\n    cnt = 0\n    while cnt &lt; len(light):\n        if light[cnt] == max_light:\n            # temporary container for all F==maxlight. For each peak it is renewed\n            h = []\n            while cnt != len(light) and light[cnt] == max(light):\n                h.append(cnt)\n                cnt += 1\n            z.append(h)\n            o.append(h[0] - 1)  # value directly at the bottom of peak is Fo\n        else:\n            cnt += 1\n    # Fm is the maximal value for each peak sequence\n    peaks = [i[np.argmax(fluorescence[i])] for i in z]\n    Fm = fluorescence[peaks]\n    return pd.Series((Fm[0] - Fm) / Fm, name=\"NPQ\", index=t[peaks])\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from mxlpy import Assimulo, Simulator, make_protocol, unwrap  from mxlbricks import names as n from mxlbricks.models import get_saadat2021   def get_npq(ppfd: pd.Series, fluorescence: pd.Series) -&gt; pd.Series:     \"\"\"Calculates the non-photochemical quenching from the extracted     important points of the PAM simulations      Returns     -------     Fm: Fm (first element of list) and Fm' values     NPQ: Calculated NPQ values     tm: Exact time points of peaks in PAM trace     Fo: Fo (first element of list) and Ft' values     to: Exact time points of Fo and Ft' values     \"\"\"     # container for lists. Each list contains the positions of fluorescence values for one peak     # container for position of Fo'     z = []     o = []     light = ppfd.to_numpy()     t = ppfd.index.to_numpy()     fluorescence = fluorescence.to_numpy()     max_light = max(light)      cnt = 0     while cnt &lt; len(light):         if light[cnt] == max_light:             # temporary container for all F==maxlight. For each peak it is renewed             h = []             while cnt != len(light) and light[cnt] == max(light):                 h.append(cnt)                 cnt += 1             z.append(h)             o.append(h[0] - 1)  # value directly at the bottom of peak is Fo         else:             cnt += 1     # Fm is the maximal value for each peak sequence     peaks = [i[np.argmax(fluorescence[i])] for i in z]     Fm = fluorescence[peaks]     return pd.Series((Fm[0] - Fm) / Fm, name=\"NPQ\", index=t[peaks]) In\u00a0[2]: Copied! <pre>protocol = make_protocol(\n    [\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 1000}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n        (120, {n.pfd(): 50}),\n        (0.8, {n.pfd(): 5000}),\n    ]\n)\n</pre> protocol = make_protocol(     [         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 1000}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),         (120, {n.pfd(): 50}),         (0.8, {n.pfd(): 5000}),     ] ) In\u00a0[3]: Copied! <pre>res = unwrap(\n    Simulator(\n        get_saadat2021().update_parameter(\"kf_cyclic_electron_flow\", 0),\n        integrator=Assimulo,\n    )\n    .simulate_protocol(protocol)\n    .get_result()\n)\n</pre> res = unwrap(     Simulator(         get_saadat2021().update_parameter(\"kf_cyclic_electron_flow\", 0),         integrator=Assimulo,     )     .simulate_protocol(protocol)     .get_result() ) In\u00a0[4]: Copied! <pre>args = res.get_args(include_parameters=True, include_readouts=True)\nfluo = args.loc[:, n.fluorescence()]\nnpq = get_npq(args.loc[:, n.pfd()], fluo)\n</pre> args = res.get_args(include_parameters=True, include_readouts=True) fluo = args.loc[:, n.fluorescence()] npq = get_npq(args.loc[:, n.pfd()], fluo) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(figsize=(10, 5))\nax.plot(fluo / fluo.max(), color=\"red\", lw=2, label=\"Fluorescence\")\nax.plot(npq, linestyle=\"dashed\", color=\"black\", lw=2, label=\"NPQ\")\nax.axvspan(0, 2 * 120, color=(0, 0, 0, 1 / 4))\nax.axvspan(12 * 120, 21 * 120, color=(0, 0, 0, 1 / 4))\nax.set(\n    ylim=(0, 1.1),\n    xlim=(0, 2500),\n    xlabel=\"Time/(s)\",\n    ylabel=\"Fluorescence (normalised)\",\n)\nax.legend(loc=\"lower right\")\nax.grid(visible=True)\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(10, 5)) ax.plot(fluo / fluo.max(), color=\"red\", lw=2, label=\"Fluorescence\") ax.plot(npq, linestyle=\"dashed\", color=\"black\", lw=2, label=\"NPQ\") ax.axvspan(0, 2 * 120, color=(0, 0, 0, 1 / 4)) ax.axvspan(12 * 120, 21 * 120, color=(0, 0, 0, 1 / 4)) ax.set(     ylim=(0, 1.1),     xlim=(0, 2500),     xlabel=\"Time/(s)\",     ylabel=\"Fluorescence (normalised)\", ) ax.legend(loc=\"lower right\") ax.grid(visible=True) plt.show()"},{"location":"saadat2021.html#coupling-alternative-electron-pathways-with-stress-response","title":"Coupling alternative electron pathways with stress response\u00b6","text":"<p>Nima P. Saadat, Tim Nies, Marvin van Aalst, Brandon Hank, B\u00fcsra Demirtas, Oliver Ebenh\u00f6h, Anna Matuszy\u0144ska</p> <p>Repeating the original work found here</p>"},{"location":"saadat2021.html#figure-2-simulated-pam-fluorescence-trace","title":"Figure 2: Simulated PAM fluorescence trace\u00b6","text":""}]}